var l=["onmount","onunmount"],e=["onerror","onload","onresize","onblur","onchange","oncontextmenu","onfocus","oninput","oninvalid","onreset","onselect","onsubmit","onkeydown","onkeypress","onkeyup","onclick","ondblclick","ondrag","ondragend","ondragenter","ondragleave","ondragover","ondragstart","ondrop","onmousedown","onmousemove","onmouseout","onmouseover","onmouseup","onscroll","onabort","oncanplay","oncanplaythrough","ondurationchange","onemptied","onended","onerror","onloadeddata","onloadedmetadata","onloadstart","onpause","onplay","onplaying","onprogress","onratechange","onseeked","onseeking","onstalled","onsuspend","ontimeupdate","onvolumechange","onwaiting"],UJ=[...e,...l],RJ=["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","big","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","meta","meter","nav","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr"],O,BJ=(J)=>{if(!O)O=document.createElement("textarea");return O.innerHTML=J,O.value},DJ=()=>{let J=0;return{getNewId:()=>++J,resetIdCounter:()=>J=0}},JJ=DJ(),L={currentIs:(J)=>window._currentAppPhase===J,start:(J)=>{window._currentAppPhase=J,console.log(`Current phase is ${J}`)}},y=(J)=>{let Q=Object.entries(J).sort((X,Y)=>X[0].localeCompare(Y[0]));return Q.forEach(([X,Y],Z)=>{if(Y&&typeof Y==="object"&&!Array.isArray(Y))Q[Z]=[X,y(Y)]}),Object.fromEntries(Q)},C=(J)=>{if(typeof J!=="object"||J===null||Array.isArray(J))return!1;return Object.prototype.toString.call(J)==="[object Object]"},x=(J)=>{if(Array.isArray(J)){let Q=[...J],X=[];return Q.forEach((Y)=>{X.push(x(Y))}),X}if(C(J)){let Q={...J},X={};return Object.keys(Q).forEach((Y)=>{X[Y]=x(Q[Y])}),Object.freeze(X)}return J},j=(J)=>{if(Array.isArray(J)){let X=[...J],Y=[];return X.forEach((Z)=>{Y.push(j(Z))}),Y}if(C(J)){let X={...J},Y={};return Object.keys(X).forEach((Z)=>{Y[Z]=j(X[Z])}),Y}return J},d=(J,Q="index")=>J.map((X,Y)=>({[Q]:Y,value:X})),GJ=(J,Q)=>{let X=y(J),Y=y(Q),Z=Object.keys(X),q=Object.keys(Y);if(Z.length!==q.length)return!1;for(let W of Z)if(!q.includes(W)||!c(X[W],Y[W]))return!1;return!0},TJ=(J,Q)=>{if(J.length!==Q.length)return!1;if(J.length===0)return!0;for(let X=0;X<J.length;X++)if(!c(J[X],Q[X]))return!1;return!0},c=(J,Q)=>{if(typeof J!==typeof Q)return!1;if(Array.isArray(J))return TJ(J,Q);if(J===null||Q===null)return J===Q;if(typeof J==="object"&&!(J instanceof Set))return GJ(J,Q);if(typeof J==="bigint"||typeof J==="number"||typeof J==="string"||typeof J==="boolean")return J===Q;return J===Q},FJ=(J,Q,X)=>{let Z=d(j(J),"index");return d(j(Q),"index").map((W)=>{let _="add",z=-1,U=W.value;return Z.some((R,m)=>{if(_=c(R.value,W.value)?R.index===W.index?"idle":"shuffle":X&&R.value[X]!==void 0&&R.value[X]===W.value[X]?"update":"add",_!=="add")return z=R.index,Z.splice(m,1),!0;return!1}),{type:_,oldIndex:z,value:U}})},E=null,S=(J)=>{let Q=x(J),X=new Set;return{type:"source-signal",get value(){if(E)X.add(E);return j(Q)},set value(Y){if(Y===Q)return;Q=x(Y),X.forEach((Z)=>Z&&Z())}}},V=(J)=>{E=J,J(),E=null},B=(J)=>{let Q,X=S(Q);return V(()=>{Q=J(Q),X.value=Q}),{type:"derived-signal",get prevValue(){return Q},get value(){return X.value}}},M=(J)=>["source-signal","derived-signal"].includes(J?.type),QJ=(J,Q)=>J?.type==="non-signal"&&(!Q||!Q.length||Q.some((X)=>typeof J?.value===X)),h=(J)=>M(J)||QJ(J),XJ=(J)=>QJ(J,["string"]),YJ=(J)=>J?.type==="non-signal"&&Array.isArray(J?.value)&&(J?.value).every((Q)=>typeof Q==="string"),w=(J)=>h(J)?J.value:J,LJ=(J)=>{if(!M(J)||!C(J.value))throw new Error("Thee argument should be signal of a plain object");return Object.keys(J.value).reduce((X,Y)=>{let Z=Y;return X[Z]=B(()=>J.value[Z]),X},{})},D=(J,...Q)=>B(()=>{return J.reduce((X,Y,Z)=>{let q,W=Q[Z];if(typeof W==="function")q=W()??"";else if(h(W))q=W.value??"";else q=W??"";return`${X}${Y}${q.toString()}`},"")}),I=(J)=>Array.isArray(J),N=(J)=>!isNaN(J?.elementId)&&J?.elementId>0,A=(J)=>typeof J==="string"||typeof J==="function"&&J.isElementGetter,v=(J)=>M(J)&&A(J.value),MJ=(J)=>A(J)||v(J),ZJ=(J)=>{return M(J)&&(A(J.value)||I(J.value)&&J.value.every((Q)=>A(Q)))},$J=(J)=>{return!M(J)&&(XJ(J)||YJ(J)||A(J)||I(J)&&J.every((Q)=>MJ(Q)))},p=(J)=>{return ZJ(J)||$J(J)},r=!1,PJ={},H={},fJ=globalThis.MutationObserver,HJ=new fJ((J)=>{J.forEach((Q)=>{if(Q.type==="childList")Q.addedNodes.forEach((X)=>{if(N(X)){let Y=X,Z=Y.elementId;if(H[Z])delete H[Z];else PJ[Z]=Y.tagName}}),Q.removedNodes.forEach((X)=>{if(N(X)){let Y=X,Z=Y.elementId,q=Y.unmountListener;if(q)H[Z]={element:Y,unmountListener:q}}})}),Object.entries(H).forEach(([Q,X])=>{let{element:Y,unmountListener:Z}=X;WJ(Y,Z)})}),WJ=(J,Q)=>{if(!N(J))return;let X=J.children;for(let Y=0;Y<X.length;Y++){let Z=X[Y];WJ(Z,Z.unmountListener)}if(Q&&Q(J),H[J.elementId])delete H[J.elementId]},AJ=()=>{if(!r&&!L.currentIs("build"))HJ.observe(document.body,{childList:!0,subtree:!0}),r=!0},qJ=(J,Q)=>UJ.includes(J)&&Q===void 0,_J=(J,Q)=>e.includes(J)&&typeof Q==="function",zJ=(J,Q)=>l.includes(J)&&typeof Q==="function",kJ=(J,Q)=>qJ(J,Q)||_J(J,Q)||zJ(J,Q),jJ=(J,Q)=>{Object.entries(Q).forEach(([X,Y])=>{if(qJ(X,Y));else if(_J(X,Y)){let Z=X.slice(2);J.addEventListener(Z,(q)=>{if(Z==="keypress")q.preventDefault();Y(q)})}else if(zJ(X,Y)){if(X==="onmount"&&!L.currentIs("build")){let Z=Y;setTimeout(()=>Z(J),0)}if(X==="onunmount")AJ(),J.unmountListener=Y}else console.error(`Invalid event key: ${X} for element with tagName: ${J.tagName}`)})},i=(J,Q,X)=>{let Y=(h(X)?X.value:X)??"";if(typeof Y==="boolean")if(Y)J.setAttribute(Q,"");else J.removeAttribute(Q);else if(Q==="value")J.value=Y;else if(Y)J.setAttribute(Q,Y)},wJ=(J,Q)=>{let X={};Object.entries(Q).forEach((Y)=>{let[Z,q]=Y;if(M(q))X[Z]=q;i(J,Z,q)}),V(()=>{Object.entries(X).forEach((Y)=>{let[Z,q]=Y,W=q.value;if(!L.currentIs("run"))return;i(J,Z,W)})})},K=(J)=>{if(v(J)){let Q=J.value;return K(Q)}if(typeof J==="string")return document.createTextNode(BJ(J));if(A(J)){let Q=J();if(!N(Q))throw new Error(`Invalid MHtml element getter child. Type: ${typeof J}`);return Q}throw new Error(`Invalid child. Type of child: ${typeof J}`)},OJ=(J,Q)=>{if(!Q)return;if(ZJ(Q))V(()=>{let Y=Q.value,Z=I(Y)?Y:[Y];Z.forEach((W,_)=>{let z=J.childNodes[_],U=K(W);if(z&&U)J.replaceChild(U,z);else if(U)J.appendChild(U);else console.error(`No child found for node with tagName: ${J.tagName}`)});let q=Z.length;while(q<J.childNodes.length){let W=J.childNodes[q];if(W)J.removeChild(W)}});if($J(Q)){let X=XJ(Q)?[Q.value]:YJ(Q)?Q.value:I(Q)?Q:[Q],Y=[];if(X.forEach((Z,q)=>{if(v(Z))Y.push({index:q,childSignal:Z});let W=K(Z),_=J.childNodes[q];if(_&&W)J.replaceChild(W,_);else if(!_&&W)J.appendChild(W);else console.error(`No child found for node with tagName: ${J.tagName}`)}),Y.length)Y.forEach(({index:Z,childSignal:q})=>{V(()=>{if(!q.value)return;if(!L.currentIs("run"))return;let W=K(q.value),_=J.childNodes[Z];if(_&&W)J.replaceChild(W,_);else if(!_&&W)J.appendChild(W);else console.error(`No child found for node with tagName: ${J.tagName}`)})})}},KJ=(J,Q)=>{let X=void 0,Y={},Z={};return Object.entries(J).forEach(([q,W])=>{if(q==="children")if(p(W))X=W;else throw new Error(`Invalid children prop for node with tagName: ${Q}

 ${JSON.stringify(W)}`);else if(kJ(q,W))Y[q]=W;else Z[q]=W}),{children:X,eventProps:Y,attributeProps:Z}},xJ=(J,Q)=>{let X=()=>{let Y=JJ.getNewId(),Z=L.currentIs("mount")?document.querySelector(`[data-elem-id="${Y}"]`):document.createElement(J);Z.elementId=Y,Z.unmountListener=void 0;let q=p(Q)?{children:Q}:Q;if(!L.currentIs("run"))q["data-elem-id"]=Z.elementId.toString();let W=KJ(q,Z.tagName);if(jJ(Z,W.eventProps),wJ(Z,W.attributeProps),OJ(Z,W.children),!L.currentIs("build"))Z.removeAttribute("data-elem-id");return Z};return X.isElementGetter=!0,X},n=(J,Q,X)=>{let Y=S(Q),Z=S(J),q,W=!1,_=()=>{if(W&&q)return q;return W=!0,q=X(B(()=>Z.value),B(()=>Y.value))(),q};return _.isElementGetter=!0,{indexSignal:Y,itemSignal:Z,mappedChild:_}},a=(J,Q,X)=>{if(Q!==void 0&&Q>=0&&X){let Y=Q>J.length?J.length:Q;J.splice(Y,0,X)}return J},EJ=({items:J,itemKey:Q,map:X,n:Y,nthChild:Z})=>{if(Z&&Y===void 0||Y!==void 0&&Y>-1&&!Z)throw new Error("Either both 'n' and 'nthChild' be passed or none of them.");let q=M(J)?J:S(w(J));if(!Q)return B(()=>a(q.value.map(X),Y,Z));let W=Z;if(Z&&typeof Z!=="string"){let P=Z(),b=()=>P;b.isElementGetter=!0,W=b}let _=q.value;if(_.length&&typeof _[0]!=="object")throw new Error("for mutable map, item in the list must be an object");let z=null,U=B((P)=>{return z=P||z,q.value}),R=B((P)=>{if(!P||!z)return U.value.map((k,F)=>n(k,F,X));return FJ(z,U.value,Q).map((T,k)=>{let F=(P||[])[T.oldIndex];if(console.assert(T.type==="add"&&T.oldIndex===-1&&!F||T.oldIndex>-1&&!!F,"In case of mutation type 'add' oldIndex should be '-1', or else oldIndex should always be a non-negative integer."),F){if(T.type==="shuffle")F.indexSignal.value=k;if(T.type==="update")F.indexSignal.value=k,F.itemSignal.value={...T.value};return F}return n(T.value,k,X)})});return B(()=>a(R.value.map((P)=>P.mappedChild),Y,W))},SJ=({condition:J,isTruthy:Q,isFalsy:X})=>{let Y=$.Span({style:"display: none;"}),Z=()=>(w(J)?Q:X)||Y;return M(J)?B(Z):Z()},VJ=({subject:J,defaultCase:Q,cases:X})=>{let Y=B(()=>w(J));return B(()=>{let Z=Y.value;return X[Z]||Q||$.Span({style:"display: none;"})})},IJ=RJ.reduce((J,Q)=>{let X=Q.split("").map((Z,q)=>!q?Z.toUpperCase():Z).join(""),Y=(Z)=>xJ(Q,Z);return J[X]=Y,J},{}),NJ={For:EJ,If:SJ,Switch:VJ},$={...IJ,...NJ},G=(J)=>(Q)=>{let X=Object.entries(Q).reduce((Y,Z)=>{let[q,W]=Z,_=typeof W==="string",z=Array.isArray(W)&&W.every((R)=>typeof R==="string"),U=M(W)||typeof W==="function"?W:_||z?{type:"non-signal",get value(){return w(W)}}:p(W)?W:{type:"non-signal",get value(){return w(W)}};return Y[q]=U,Y},{});return J(X)},bJ=G(({logoSrc:J,logoHref:Q,logoSize:X,labelComponent:Y})=>{let Z=D`${()=>X?.value||32}`;return $.A({class:"space-mono link black flex items-center justify-start",href:Q,children:[$.Img({src:J,height:Z,width:Z}),$.If({condition:Y,isTruthy:Y})]})}),sJ=G(({children:J})=>$.Div({class:"flex items-center",children:J})),u=G(({classNames:J,href:Q,label:X,onClick:Y})=>{return $.Button({class:D`pv2 ph3 pointer bg-transparent hover-bg-gray b--gray ba bw1 br-pill ${J}`,onclick:Y,children:$.A({class:"no-underline dark-gray hover-white",href:Q,children:X})})}),t=G(({className:J})=>$.Div({class:D`bl b--moon-gray min-vh-20 ${J}`})),s=G(({classNames:J,colorCss:Q,target:X,isSelected:Y,href:Z,label:q})=>{return $.A({class:D`link underline ${()=>Q?.value||"red"} ${()=>Y?.value?`bg-${Q?.value||"red"}`:""} ${J}`,target:X,href:Z,children:q})}),gJ=G(({logoSize:J,logoSrc:Q,logoHref:X,logoLabelComponent:Y,links:Z,rightmostComponent:q})=>{return $.Div({class:"pv3 bg-pale flex items-center justify-between",children:[bJ({logoSize:J,logoSrc:Q,logoHref:X,labelComponent:Y}),$.Div({class:"flex items-center justify-end",children:$.For({items:Z,itemKey:"label",n:q?1/0:-1,nthChild:q,map:(W)=>{let _=LJ(W);return s({isSelected:_.isSelected,classNames:"ml3 pv1 ph2",colorCss:_.colorCss,href:_.href,label:_.label})}})})]})}),yJ=G(({classNames:J,children:Q})=>{return $.Div({class:D`dn db-ns overflow-y-scroll ${J}`,style:`
      scrollbar-color: #e8e8e8 #f2f1f0;
      scrollbar-width: thin;
    `,children:Q})}),g=G(({classNames:J,titleClassNames:Q,itemClassNames:X,header:Y,justifyRight:Z,links:q,linkColorCss:W,bottomComponent:_})=>$.Div({class:D`${()=>Z?.value?"tr":""} ${J}`,children:[$.P({class:D`space-mono mt0 f3 lh-solid ${Q}`,children:Y}),$.Div($.For({items:q,map:(z)=>$.Div({class:X,children:[s({colorCss:W,href:z.href,label:z.label})]})})),$.If({condition:_,isTruthy:_})]})),o=G(({classNames:J,contentClassNames:Q,children:X})=>{return $.Div({class:D`w-100 bg-pale ${J}`,children:[$.Div({class:D`mw8 center ${Q}`,children:X})]})}),oJ=$.Div({children:[$.Div({id:"about-us",class:"f2 space-mono lh-copy mt5",children:["# ",$.Span({class:"highlight",children:"&nbsp;about us&nbsp;"})]}),$.Div({class:"pa5",children:[$.Div({class:"flex items-stretch",children:[$.Img({class:"mr4 flip",src:"/assets/images/founder.jpg",height:"200",width:"200"}),$.Div({children:[$.H3({class:"mt0 mb0",children:"Chandan Kumar, Founder & CTO"}),$.P({class:"ma1 silver",children:`A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.`})]})]}),u({classNames:"mt4 mb5",label:"Check out careers at Cyfer",onClick:()=>location.assign("/products")})]})]}),mJ=$.Div({children:[$.Div({id:"blogs",class:"f2 space-mono lh-copy mt5",children:["# ",$.Span({class:"highlight",children:"&nbsp;blogs&nbsp;"})]}),$.Div({class:"pa5",children:[$.Div({class:"flex items-stretch mb5",children:[$.Img({class:"mr4",src:"/assets/images/light-code-screenshot.png",width:"360"}),$.Div({children:[$.H3({class:"mt0 mb0",children:"Dilemma of flux pattern and React"}),$.P({class:"ma1 silver",children:`A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.`})]})]}),$.Div({class:"flex items-stretch mb4",children:[$.Div({children:[$.H3({class:"mt0 mb0",children:"Dilemma of flux pattern and React"}),$.P({class:"ma1 silver",children:`A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.`})]}),$.Img({class:"ml4",src:"/assets/images/light-code-screenshot.png",width:"360"})]}),u({classNames:"mb5",href:"/blogs",label:"Check out all blogs"})]})]}),CJ=o({classNames:"bg-pale-dark",contentClassNames:"flex items-start justify-between pv4",children:[$.Div({class:"flex flex-column items-stretch justify-between",children:[$.Div({children:[$.A({class:"flex items-center justify-start no-underline",href:"/",children:[$.Img({src:"/assets/images/cyfer-logo.png",height:"32",width:"32"})]}),$.P({class:"m0 f7",children:"© 2024 Cyfer Tech."}),$.P({class:"nt2 f7",children:"All rights reserved."})]}),$.Span({class:"mt4 pt3 mb0",children:[$.Span({children:"This site is created using "}),s({classNames:"underline",href:"maya",label:"Maya"}),$.Span({children:"."})]})]}),$.Div({class:"flex items-start justify-between",children:[g({justifyRight:!0,classNames:"pr3",itemClassNames:"mb3",header:"Company",links:[{label:"About us",href:"#about-us"},{label:"Blogs",href:"#blogs"},{label:"Team",href:"#about-us"},{label:"Career",href:"/careers"}]}),t({className:"mh4 ph2"}),g({justifyRight:!0,classNames:"pr3",itemClassNames:"mb3",header:"Products",links:[{label:"Maya",href:"/products/maya"},{label:"KarmaJs",href:"/karma"},{label:"Yajman",href:"/yajman"},{label:"Batua",href:"/batua"}]}),t({className:"mh4 ph2"}),$.Div({children:[g({justifyRight:!0,itemClassNames:"mb3",header:"Relations",links:[{label:"Sponsor Us",href:"/sponsor-us"},{label:"FAQs",href:"/faqs"},{label:"Feedback",href:"/feedback"}],bottomComponent:$.Span({class:"flex items-center justify-end",children:[$.A({target:"_blank",href:"https://github.com/thecyfertech",children:[$.Img({class:"ba b--none br-100",src:"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",height:"32",width:"32"})]}),$.A({class:"ml3",target:"_blank",href:"https://twitter.com/thecyfertech",children:[$.Img({class:"ba b--none br-100",src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAAAAABXZoBIAAAA/0lEQVR4AbXPIazCMACE4d+L2qoZFEGSIGcRc/gJJB5XMzGJmK9EN0HMi+qaibkKVF1txdQe4g0YzPK5yyWXHL9TaPNQ89LojH87N1rbJcXkMF4Fk31UMrf34hm14KUeoQxGArALHTMuQD2cAWQfJXOpgTbksGr9ng8qluShJTPhyCdx63POg7rEim95ZyR68I1ggQpnCEGwyPicw6hZtPEGmnhkycqOio1zm6XuFtyw5XDXfGvuau0dXHzJp8pfBPuhIXO9ZK5ILUCdSvLYMpc6ASBtl3EaC97I4KaFaOCaBE9Zn5jUsVqR2vcTJZO1DdbGoZryVp94Ka/mQfE7f2T3df0WBhLDAAAAAElFTkSuQmCC",height:"24",width:"24"})]})]})})]})]})]}),cJ=()=>{let J=document.location.hash;return o({classNames:"sticky top-0",contentClassNames:"z-max bg-pale",children:gJ({logoHref:"/",logoSrc:"/assets/images/cyfer-logo.png",logoSize:56,logoLabelComponent:$.A({class:"ml2 link black no-underline",href:"/",children:[$.Div({class:"f4",children:"CYFER"}),$.Div({class:"f4",children:"TECH"})]}),links:[{isSelected:J==="#products",href:"/#products",label:"Products"},{isSelected:J==="#blogs",href:"/#blogs",label:"Blogs"},{isSelected:J==="#about-us",href:"/#about-us",label:"About Us"}],rightmostComponent:$.A({class:"ml4",href:"https://github.com/thecyfertech",children:[$.Img({class:"ba b--none br-100",src:"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",height:"40",width:"40"})]})})})},hJ=G(({title:J,app:Q})=>{return $.Html({lang:"en",children:[$.Head([$.Title(J),$.Link({rel:"stylesheet",href:"/assets/styles.css"}),$.Link({rel:"icon",type:"image/x-icon",href:"/assets/favicon.ico"})]),$.Body([$.Script({src:"main.js",defer:!0}),cJ(),Q,CJ])]})}),vJ={title:"Products Showcase",products:[{title:"Maya UI Framework",subtitle:"NPM Package",size:32,logoSrc:"/assets/images/maya-logo.png",description:[`A TypeScript only web framework which generates MPA (multi-page
        application) and only needs file server to host the app as opposed
        to other popular web framewroks which creates mostly an SPA and
        needs app server.`]},{title:"Signal",subtitle:"NPM Package",size:40,logoSrc:"/assets/images/signal-logo.png",description:[`Signals are basic data units that can automatically alert functions
        or computations when the data it holds changes. This library is a
        TypeScript implementation of signals.`]},{title:"Batua",subtitle:"Web App",logoSrc:"/assets/images/batua-logo.png",description:[`A tag based personal money tracker app. The flexibile user-defined
        tags, unlike fixed categories helps in classifying and monitoring expenses
        and earnings more effectively with detailed charts and graphs.`]},{title:"YouTube Attention Score",subtitle:"Chrome Extenstion",logoSrc:"/assets/images/yt-attention-score-logo.png",description:[`A chrome extension for YouTube videos which calculates a score to indicate
        how attention-worthy a video is. It simply derives and shows a ratio of total
        number of likes over total number of views of the video.`]}]},dJ=$.Div([$.Div({id:"products",class:"f2 space-mono lh-copy",children:["# ",$.Span({class:"highlight",children:"&nbsp;products&nbsp;"})]}),$.Div({class:"pa5",children:[$.Div({class:"flex flex-wrap justify-between",children:$.For({items:vJ.products,map:({title:J,subtitle:Q,size:X,logoSrc:Y,description:Z})=>$.Div({class:"w-45 mb4",children:[$.Div({class:"flex items-center",children:[$.Img({src:Y,height:`${X??36}`,width:`${X??36}`}),$.Div({class:"ml3",children:[$.H3({class:"ma0",children:J}),$.Div({class:"gray",children:Q})]})]}),$.Div({class:"mt3 silver",children:$.For({items:Z,map:(q)=>$.P({class:"mt0 mb3",children:q})})})]})})}),u({classNames:"mb4",href:"/products",label:"Check out all products"})]})]),f=[{title:"Why, modern web development should go back to its roots again. To MPA.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]},{title:"Seemingly hacky syntaxes in React by design.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]},{title:"You don't need React to to create your first PWA. Choose Maya instead.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]},{title:"The constant loading of resources as users navigate between different sections.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]}],pJ=hJ({title:"Blogs",app:o({contentClassNames:"pt4 pb5",children:$.Div({class:"gray grid grid-col-2-5 gap2",children:[yJ({classNames:"pa2 sticky top-55",children:$.For({items:[...f.map((J)=>J.title),...f.map((J)=>J.title),...f.map((J)=>J.title),...f.map((J)=>J.title)],map:(J,Q)=>$.Div({class:D`ba br3 pa3 mb3 ${Q===4?"b--transparent b black":"b--near-white moon-gray shadow-hover"}`,children:J})})}),$.Div({children:$.For({items:f[0].paras,n:0,nthChild:$.H1({class:"mv0",children:f[0].title}),map:(J)=>$.If({condition:J.startsWith("##"),isTruthy:$.H3({class:"mt4 mb2",children:J.replaceAll("##","")}),isFalsy:$.P({class:"lh-copy",children:J})})})})]})})}),uJ=()=>{L.start("mount"),JJ.resetIdCounter(),pJ(),L.start("run")};uJ();
