var p=(Q)=>{let Z=Object.entries(Q).sort((J,X)=>J[0].localeCompare(X[0]));return Z.forEach(([J,X],$)=>{if(X&&typeof X==="object"&&!Array.isArray(X))Z[$]=[J,p(X)]}),Object.fromEntries(Z)},y=(Q)=>{if(typeof Q!=="object"||Q===null||Array.isArray(Q))return!1;return Object.prototype.toString.call(Q)==="[object Object]"},E=(Q)=>{if(Array.isArray(Q)){let Z=[...Q],J=[];return Z.forEach((X)=>{J.push(E(X))}),J}if(y(Q)){let Z={...Q},J={};return Object.keys(Z).forEach((X)=>{J[X]=E(Z[X])}),Object.freeze(J)}return Q},j=(Q)=>{if(Array.isArray(Q)){let J=[...Q],X=[];return J.forEach(($)=>{X.push(j($))}),X}if(y(Q)){let J={...Q},X={};return Object.keys(J).forEach(($)=>{X[$]=j(J[$])}),X}return Q},l=(Q,Z="index")=>Q.map((J,X)=>({[Z]:X,value:J})),PQ=(Q,Z)=>{let J=p(Q),X=p(Z),$=Object.keys(J),W=Object.keys(X);if($.length!==W.length)return!1;for(let q of $)if(!W.includes(q)||!u(J[q],X[q]))return!1;return!0},KQ=(Q,Z)=>{if(Q.length!==Z.length)return!1;if(Q.length===0)return!0;for(let J=0;J<Q.length;J++)if(!u(Q[J],Z[J]))return!1;return!0},u=(Q,Z)=>{if(typeof Q!==typeof Z)return!1;if(Array.isArray(Q))return KQ(Q,Z);if(Q===null||Z===null)return Q===Z;if(typeof Q==="object"&&!(Q instanceof Set))return PQ(Q,Z);if(typeof Q==="bigint"||typeof Q==="number"||typeof Q==="string"||typeof Q==="boolean")return Q===Z;return Q===Z},MQ=(Q,Z,J)=>{let $=l(j(Q),"index");return l(j(Z),"index").map((q)=>{let U="add",G=-1,K=q.value;return $.some((_,N)=>{if(U=u(_.value,q.value)?_.index===q.index?"idle":"shuffle":J&&_.value[J]!==void 0&&_.value[J]===q.value[J]?"update":"add",U!=="add")return G=_.index,$.splice(N,1),!0;return!1}),{type:U,oldIndex:G,value:K}})},xQ=(Q)=>{let Z=(J)=>Q((X)=>{let $=Array.from(X);return J($),$});return{copyWithin:(...J)=>Z((X)=>X.copyWithin(...J)),fill:(...J)=>Z((X)=>X.fill(...J)),pop:(...J)=>Z((X)=>X.pop(...J)),push:(...J)=>Z((X)=>X.push(...J)),remove:(...J)=>{let X=J[0],$=(...W)=>!X(...W);J[0]=$,Q((W)=>{return W.filter(...J)})},reverse:(...J)=>Z((X)=>X.reverse(...J)),shift:(...J)=>Z((X)=>X.shift(...J)),sort:(...J)=>Z((X)=>X.sort(...J)),splice:(...J)=>Z((X)=>X.splice(...J)),unshift:(...J)=>Z((X)=>X.unshift(...J))}},jQ=(Q)=>{return{set:(Z)=>Q((J)=>({...J,...Z}))}},m=null,t=(Q)=>m=Q,I=(Q)=>{let Z=E(Q),J=new Set,X=()=>{J.forEach((q)=>{if(q.canDisposeNow){J.delete(q);return}q()})},$=(q)=>{Z=q,X()},W={type:"source-signal",get value(){if(m)J.add(m);return j(Z)},set value(q){if(q===Z)return;$(E(q))}};return Array.isArray(Q)?Object.assign(W,xQ((q)=>$(q(Z)))):typeof Q==="object"&&Q!==null?Object.assign(W,jQ((q)=>$(q(Z)))):W},V=(Q)=>{let Z=Q;return Z.canDisposeNow=!1,Z.dispose=()=>{Z.canDisposeNow=!0},t(Z),Q(),t(null),Z},B=(Q)=>{let Z,J=I(Z),X=V(()=>{Z=Q(Z),J.value=Z});return{type:"derived-signal",get prevValue(){return Z},get value(){return J.value},dispose(){X.dispose()}}},OQ=(Q)=>{return{type:"non-signal",value:Q}},z=(Q)=>C(Q)?Q.value:Q,P=(Q)=>["source-signal","derived-signal"].includes(Q?.type),g=(Q,Z)=>Q?.type==="non-signal"&&(!Z||!Z.length||Z.some((J)=>typeof Q?.value===J)),C=(Q)=>P(Q)||g(Q),r=(...Q)=>Q.map((Z)=>z(Z)),w=(Q)=>{return{get string(){return B(()=>{let Z=z(Q);return Z===void 0||Z===null?void 0:Z.toString()})},or:(Z)=>B(()=>z(Q)||z(Z))}},wQ=(Q)=>{let J=["at","copyWithin","fill","includes","indexOf","join","lastIndexOf","slice","with"].reduce((X,$)=>{let W=(...q)=>{return B(()=>{let U=r(...q);return z(Q)[$](...U)})};return X[$]=W,X},{});return{...w(Q),...J,concat:(X)=>B(()=>z(Q).concat(z(X))),every:(X)=>B(()=>z(Q).every(X)),filter:(X)=>B(()=>z(Q).filter(X)),find:(X)=>B(()=>z(Q).find(X)),findIndex:(X)=>B(()=>z(Q).findIndex(X)),findLast:(X)=>B(()=>z(Q).findLast(X)),findLastIndex:(X)=>B(()=>z(Q).findLastIndex(X)),get lastItem(){return B(()=>{return j(z(Q)).pop()})},get length(){return B(()=>z(Q).length)},map:(X)=>B(()=>z(Q).map(X)),partition:(X)=>{let $=B(()=>z(Q).filter(X)),W=B(()=>z(Q).filter((q,U,G)=>!X(q,U,G)));return[$,W]},reduce:(X,$)=>B(()=>z(Q).reduce(X,$)),reduceRight:(X,$)=>B(()=>z(Q).reduceRight(X,$)),get reversed(){return B(()=>z(Q).toReversed())},some:(X)=>B(()=>z(Q).every(X)),toSorted:(X)=>B(()=>z(Q).toSorted(X)),toSpliced:(X,$,...W)=>B(()=>z(Q).toSpliced(z(X),z($),...W))}},NQ=(Q)=>{let J=["toExponential","toFixed","toPrecision"].reduce((X,$)=>{let W=(...q)=>{return B(()=>{let U=r(...q);return z(Q)[$](...U)})};return X[$]=W,X},{});return{...w(Q),...J,toConfined:(X,$)=>B(()=>z(Q)<z(X)?z(X):z(Q)>z($)?z($):z(Q)),toLocaleString:(X,$)=>B(()=>z(Q).toLocaleString(z(X),$))}},SQ=(Q)=>{if(!y(z(Q)))throw new Error("Thee argument should be a plain object or a signal of plain object");return{...w(Q),prop:(Z)=>B(()=>z(Q)[Z]),get props(){return Object.keys(z(Q)).reduce((J,X)=>{let $=X;return J[$]=this.prop($),J},{})},get keys(){return B(()=>Object.keys(z(Q)))}}},YQ=(Q)=>{let J=["at","charAt","charCodeAt","codePointAt","concat","endsWith","includes","indexOf","lastIndexOf","padEnd","padStart","repeat","slice","startsWith","substring","trim","trimEnd","trimStart"].reduce((X,$)=>{let W=(...q)=>{return B(()=>{let U=r(...q);return z(Q)[$](...U)})};return X[$]=W,X},{});return{...w(Q),...J,get length(){return B(()=>z(Q).length)},get lowercase(){return B(()=>z(Q).toLowerCase())},get Sentencecase(){return B(()=>{let X=z(Q);return X.charAt(0).toUpperCase()+X.slice(1).toLowerCase()})},get TitleCase(){return B(()=>z(Q).toLowerCase().replace(/\b\w/g,(X)=>X.toUpperCase()))},get UPPERCASE(){return B(()=>z(Q).toUpperCase())},localeCompare:(X,$,W)=>B(()=>z(Q).localeCompare(z(X),z($),W)),normalize:(X)=>B(()=>z(Q).normalize(z(X))),replace:(X,$)=>B(()=>z(Q).replace(z(X),z($))),replaceAll:(X,$)=>B(()=>z(Q).replaceAll(z(X),z($))),search:(X)=>B(()=>z(Q).search(X)),split:(X,$)=>B(()=>{let W=X instanceof RegExp?X:z(X);return z(Q).split(W,z($))}),toLocaleLowerCase:(X)=>B(()=>z(Q).toLocaleLowerCase(z(X))),toLocaleUpperCase:(X)=>B(()=>z(Q).toLocaleUpperCase(z(X)))}},fQ=I("dksjfbksjnd"),RX=YQ(fQ).split(""),EQ=(Q)=>{return typeof z(Q)==="number"?NQ(Q):typeof z(Q)==="string"?YQ(Q):Array.isArray(z(Q))?wQ(Q):y(z(Q))?SQ(Q):w(Q)},F=(Q,...Z)=>B(()=>{return Q.reduce((J,X,$)=>{let W,q=Z[$];if(typeof q==="function")W=q()??"";else if(C(q))W=q.value??"";else W=q??"";return`${J}${X}${W.toString()}`},"")}),WQ=["onmount","onunmount"],qQ=["onerror","onload","onresize","onblur","onchange","oncontextmenu","onfocus","oninput","oninvalid","onreset","onselect","onsubmit","onkeydown","onkeypress","onkeyup","onclick","ondblclick","ondrag","ondragend","ondragenter","ondragleave","ondragover","ondragstart","ondrop","onmousedown","onmousemove","onmouseout","onmouseover","onmouseup","onscroll","onabort","oncanplay","oncanplaythrough","ondurationchange","onemptied","onended","onerror","onloadeddata","onloadedmetadata","onloadstart","onpause","onplay","onplaying","onprogress","onratechange","onseeked","onseeking","onstalled","onsuspend","ontimeupdate","onvolumechange","onwaiting"],IQ=[...qQ,...WQ],VQ=["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","big","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","meta","meter","nav","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr"],S,zQ=(Q)=>{if(!S)S=document.createElement("textarea");return S.innerHTML=Q,S.value},bQ=(Q)=>{try{return decodeURIComponent(Q)}catch{return Q}},yQ=(Q)=>{return Q.replace(/\\u[\dA-Fa-f]{4}/g,(Z)=>String.fromCharCode(parseInt(Z.slice(2),16))).replace(/\\x[\dA-Fa-f]{2}/g,(Z)=>String.fromCharCode(parseInt(Z.slice(2),16)))},gQ=()=>{let Q=0;return{getNewId:()=>++Q,resetIdCounter:()=>Q=0}},BQ=gQ(),H={currentIs:(Q)=>window._currentAppPhase===Q,start:(Q)=>{window._currentAppPhase=Q,console.log(`Current phase is ${Q}`)}},UQ=(Q,Z,J)=>{let X=Q;X=zQ(X),X=bQ(X),X=yQ(X);let $=X.trim().toLowerCase();for(let W of Z)if(W.test($))throw J;return Q},CQ=(Q)=>UQ(Q,[/^javascript\s*:/i,/^data\s*:/i,/^vbscript\s*:/i,/^file\s*:/i],'The href attribute value starting with one of "javascript:", "data:", "vbscript:" or "file:" is not allowed.'),hQ=(Q)=>UQ(Q,[/url\s*\(/i,/expression\s*\(/i,/javascript\s*:/i,/data\s*:/i,/vbscript\s*:/i,/file\s*:/i],'The style attribute value starting with one of "url(..", "expression(..", "javascript:", "data:", "vbscript:" or "file:" is not allowed.'),cQ=(Q,Z)=>{if(Q==="href"){if(typeof Z==="boolean")throw"The value of 'href' attribute should not be a boolean";return CQ(Z||"")}if(Q==="style"){if(typeof Z==="boolean")throw"The value of 'style' attribute should not be a boolean";return hQ(Z||"")}return Z},i=(Q)=>Array.isArray(Q),b=(Q)=>!isNaN(Q?.elementId)&&Q?.elementId>0,A=(Q)=>Q===void 0||typeof Q==="string"||typeof Q==="function"&&Q.isElementGetter,GQ=(Q)=>i(Q)&&Q.every((Z)=>A(Z)),DQ=(Q)=>A(Q)||GQ(Q),_Q=(Q)=>g(Q)&&A(Q.value),d=(Q)=>P(Q)&&A(Q.value),vQ=(Q)=>g(Q)&&DQ(Q.value),RQ=(Q)=>P(Q)&&DQ(Q.value),FQ=(Q)=>i(Q)&&Q.every((Z)=>A(Z)||_Q(Z)||d(Z)),sQ=(Q)=>!P(Q)&&(A(Q)||vQ(Q)||FQ(Q)),LQ=(Q)=>sQ(Q)||RQ(Q),e=!1,oQ={},x={},pQ=globalThis.MutationObserver,mQ=new pQ((Q)=>{Q.forEach((Z)=>{if(Z.type==="childList")Z.addedNodes.forEach((J)=>{if(b(J)){let X=J,$=X.elementId;if(x[$])delete x[$];else oQ[$]=X.tagName}}),Z.removedNodes.forEach((J)=>{if(b(J)){let X=J,$=X.elementId,W=X.unmountListener;if(W)x[$]={element:X,unmountListener:W}}})}),Object.entries(x).forEach(([Z,J])=>{let{element:X,unmountListener:$}=J;TQ(X,$)})}),TQ=(Q,Z)=>{if(!b(Q))return;let J=Q.children;for(let X=0;X<J.length;X++){let $=J[X];TQ($,$.unmountListener)}if(Z&&Z(Q),x[Q.elementId])delete x[Q.elementId]},dQ=()=>{if(!e&&!H.currentIs("build"))mQ.observe(document.body,{childList:!0,subtree:!0}),e=!0},kQ=(Q,Z)=>IQ.includes(Q)&&Z===void 0,HQ=(Q,Z)=>qQ.includes(Q)&&typeof Z==="function",AQ=(Q,Z)=>WQ.includes(Q)&&typeof Z==="function",uQ=(Q,Z)=>kQ(Q,Z)||HQ(Q,Z)||AQ(Q,Z),rQ=(Q,Z)=>{Object.entries(Z).forEach(([J,X])=>{if(kQ(J,X));else if(HQ(J,X)){let $=J.slice(2);Q.addEventListener($,(W)=>{if($==="keypress")W.preventDefault();X(W)})}else if(AQ(J,X)){if(J==="onmount"&&!H.currentIs("build")){let $=X;setTimeout(()=>$(Q),0)}if(J==="onunmount"){dQ();let $=Q.unmountListener;Q.unmountListener=(W)=>{if(X(W),typeof $==="function")$(W)}}}else console.error(`Invalid event key: ${J} for element with tagName: ${Q.tagName}`)})},QQ=(Q,Z,J)=>{let X=C(J)?J.value:J,$=cQ(Z,X);if(typeof $==="boolean")if($)Q.setAttribute(Z,"");else Q.removeAttribute(Z);else if(Z==="value")Q.value=$||"";else Q.setAttribute(Z,$||"")},iQ=(Q,Z)=>{let J={};Object.entries(Z).forEach(($)=>{let[W,q]=$;if(P(q))J[W]=q;QQ(Q,W,q)});let X=V(()=>{Object.entries(J).forEach(($)=>{let[W,q]=$,U=q.value;if(!H.currentIs("run"))return;QQ(Q,W,U)})});Q.effects.push(X)},nQ=(Q)=>{if(!Q||typeof Q==="string")return document.createTextNode(zQ(Q||""));if(A(Q)){let Z=Q();if(!b(Z))throw new Error(`Invalid MHtml element getter child. Type: ${typeof Q}`);return Z}throw new Error(`Invalid child. Type of child: ${typeof Q}`)},v=(Q,Z,J)=>{let X=Q.childNodes[J],$=nQ(Z);if(X&&$)Q.replaceChild($,X);else if($)Q.appendChild($);else console.error(`No child found for node with tagName: ${Q.tagName}`)},aQ=(Q,Z)=>{if(!Z)return;if(RQ(Z)){let $=V(()=>{let W=Z.value,q=i(W)?W:[W];q.forEach((G,K)=>v(Q,G,K));let U=q.length;while(U<Q.childNodes.length){let G=Q.childNodes[U];if(G)Q.removeChild(G)}});Q.effects.push($)}let J=A(Z)?[Z]:g(Z)?A(Z.value)?[Z.value]:GQ(Z.value)?Z.value:[]:FQ(Z)?Z.map(($)=>d($)?$:_Q($)?$.value:$):[],X=[];if(J.forEach(($,W)=>{if(d($))X.push({index:W,signalChild:$});let q=z($);v(Q,q,W)}),X.length)X.forEach(({index:$,signalChild:W})=>{let q=V(()=>{let U=W.value;if(!H.currentIs("run"))return;v(Q,U,$)});Q.effects.push(q)})},lQ=(Q,Z)=>{let J=void 0,X={},$={};return Object.entries(Q).forEach(([W,q])=>{if(W==="children")if(LQ(q))J=q;else throw new Error(`Invalid children prop for node with tagName: ${Z}

 ${JSON.stringify(q)}`);else if(uQ(W,q))X[W]=q;else $[W]=q}),{children:J,eventProps:X,attributeProps:$}},tQ=(Q,Z)=>{let J=()=>{let X=BQ.getNewId(),$=H.currentIs("mount")?document.querySelector(`[data-elem-id="${X}"]`):document.createElement(Q);$.elementId=X,$.effects=[],$.unmountListener=()=>{$.effects.forEach((U)=>U.dispose())};let W=LQ(Z)?{children:Z}:Z;if(!H.currentIs("run"))W["data-elem-id"]=$.elementId.toString();let q=lQ(W,$.tagName);if(rQ($,q.eventProps),iQ($,q.attributeProps),aQ($,q.children),!H.currentIs("build"))$.removeAttribute("data-elem-id");return $};return J.isElementGetter=!0,J},XQ=(Q,Z,J)=>{let X=I(Z),$=I(Q),W=J(B(()=>$.value),B(()=>X.value)),q,U,G=!1;if(W?.isElementGetter)q=()=>{if(G&&U)return U;return U=W(),G=!0,U},q.isElementGetter=!0;else if(!W||typeof W==="string")q=W||"";else throw`One of the child, ${W} passed in ForElement is invalid.`;return{indexSignal:X,itemSignal:$,mappedChild:q}},s=(Q,Z,J)=>{if(Z!==void 0&&Z>=0&&J){let X=Z>Q.length?Q.length:Z;Q.splice(X,0,J)}return Q},eQ=({subject:Q,itemKey:Z,map:J,n:X,nthChild:$})=>{if($&&X===void 0||X!==void 0&&X>-1&&!$)throw new Error("Either both 'n' and 'nthChild' be passed or none of them.");let W=$;if($&&typeof $!=="string"){let R=$(),c=()=>R;c.isElementGetter=!0,W=c}if(!P(Q))return s(z(Q).map(J),X,W);let q=B(()=>{let R=z(Q);return Array.isArray(R)?R:[]});if(!Z)return B(()=>s(q.value.map(J),X,W));let U=q.value;if(U.length&&typeof U[0]!=="object")throw new Error("for mutable map, item in the list must be an object");let G=null,K=B((R)=>{return G=R||G,q.value}),_=B((R)=>{if(!R||!G)return K.value.map((O,k)=>XQ(O,k,J));return MQ(G,K.value,Z).map((T,O)=>{let k=(R||[])[T.oldIndex];if(console.assert(T.type==="add"&&T.oldIndex===-1&&!k||T.oldIndex>-1&&!!k,"In case of mutation type 'add' oldIndex should be '-1', or else oldIndex should always be a non-negative integer."),k){if(T.type==="shuffle")k.indexSignal.value=O;if(T.type==="update")k.indexSignal.value=O,k.itemSignal.value={...T.value};return k}return XQ(T.value,O,J)})});return B(()=>s(_.value.map((R)=>R.mappedChild),X,W))},QX=({subject:Q,isTruthy:Z,isFalsy:J})=>{let X=Y.Span({style:"display: none;"}),$=()=>z(Q)?Z?Z(Q):X:J?J(Q):X;return P(Q)?B($):$()},XX=({subject:Q,caseMatcher:Z,defaultCase:J,cases:X})=>{let $=()=>{let W=z(Q),q=z(X),U=void 0;for(let[G,K]of Object.entries(q)){let _=Z&&Z(W,G),N=`${W}`===G;if(_||N){U=K();break}}return U||J&&J()||Y.Span({style:"display: none;"})};return P(Q)?B($):$()},ZX=VQ.reduce((Q,Z)=>{let J=Z.split("").map(($,W)=>!W?$.toUpperCase():$).join(""),X=($)=>tQ(Z,$);return Q[J]=X,Q},{}),$X={For:eQ,If:QX,Switch:XX},Y={...ZX,...$X},JX=(Q)=>{let Z=z(Q);return Array.isArray(Z)&&Z.some((J)=>C(J))},L=(Q)=>(Z)=>{for(let X of Object.keys(Z))if(Z[X]===void 0)delete Z[X];let J=Object.entries(Z).reduce((X,$)=>{let[W,q]=$,U=P(q)||typeof q==="function"?q:JX(q)?z(q):OQ(z(q));return X[W]=U,X},{});return Q(J)},D={ASSETS:{FAVICON:"/assets/favicon.ico",LOGOS:{BATUA:"/assets/images/batua-logo.png",CYFER:"/assets/images/cyfer-logo.png",MAYA:"/assets/images/maya-logo.png",SIGNAL:"/assets/images/signal-logo.png",YT_ATTENTION_SCORE:"/assets/images/yt-attention-score-logo.png"},IMAGES:{FOUNDER:"/assets/images/founder.jpg"},SCREENSHOTS:{CODE_EXAMPLE:{LIGHT:"/assets/images/light-code-screenshot.png"}},STYLESHEET:"/assets/styles.css"},LINKS:{LOGOS:{X:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAAAAABXZoBIAAAA/0lEQVR4AbXPIazCMACE4d+L2qoZFEGSIGcRc/gJJB5XMzGJmK9EN0HMi+qaibkKVF1txdQe4g0YzPK5yyWXHL9TaPNQ89LojH87N1rbJcXkMF4Fk31UMrf34hm14KUeoQxGArALHTMuQD2cAWQfJXOpgTbksGr9ng8qluShJTPhyCdx63POg7rEim95ZyR68I1ggQpnCEGwyPicw6hZtPEGmnhkycqOio1zm6XuFtyw5XDXfGvuau0dXHzJp8pfBPuhIXO9ZK5ILUCdSvLYMpc6ASBtl3EaC97I4KaFaOCaBE9Zn5jUsVqR2vcTJZO1DdbGoZryVp94Ka/mQfE7f2T3df0WBhLDAAAAAElFTkSuQmCC",GITHUB:"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"},CYFER:{MAYA:"https://maya.cyfer.tech",GITHUB:"https://github.com/cyftec",X:"https://x.com/cyftec"}}},M=[{title:"Why, modern web development should go back to its roots again. To MPA.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]},{title:"Seemingly hacky syntaxes in React by design.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]},{title:"You don't need React to to create your first PWA. Choose Maya instead.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]},{title:"The constant loading of resources as users navigate between different sections.",synopsis:"In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.",paras:["In today’s web development world, Single Page Applications (SPAs) and Multi-Page Applications (MPAs) are two of the most common approaches for building websites and apps. Both have their advantages, but SPAs, while popular due to their smooth user experience, come with some significant drawbacks when compared to traditional MPAs. In this post, we’ll delve into why SPAs can be worse than MPAs, highlighting issues around performance, SEO, user experience, and development complexity.","##The Performance Pitfall##","One of the key selling points of SPAs is that they offer a seamless experience. Once the initial page is loaded, content is updated dynamically, often without refreshing the entire page. However, this dynamic approach can lead to serious performance problems, especially as the application grows in complexity.","When a user first loads a SPA, the browser needs to download a large JavaScript bundle. Depending on the size of this bundle, this initial load can be slow, leading to a poor first impression. In an MPA, each page is typically loaded with its own resources, meaning that users can start interacting with the website almost immediately, while the rest of the content loads in the background. In contrast, SPAs tend to rely on a hefty initial load, which can be frustrating, especially in regions with slow internet connections or on mobile devices.","The constant loading of resources as users navigate between different sections of the application can also lead to jarring experiences. MPAs, on the other hand, handle these transitions more smoothly by refreshing only the parts of the page that need updating, making them more reliable in terms of performance.","##SEO Struggles##","Another critical downside to SPAs is how they handle search engine optimization (SEO). In SPAs, content is often loaded dynamically via JavaScript, meaning the actual HTML served to search engine crawlers might be quite bare-bones. This makes it difficult for search engines to index the site properly, resulting in poor visibility in search results. Even though there are workarounds—like server-side rendering (SSR) or prerendering—these solutions add layers of complexity and can’t fully replicate the SEO-friendliness of MPAs.","MPAs, in contrast, are inherently better suited for SEO. Since each page is a distinct URL, search engines can easily crawl, index, and rank individual pages. Content is already rendered on the server, so there’s no need for complicated workarounds to make sure search engines can read it. For websites that rely heavily on organic traffic, the inability to properly optimize a SPA can be a dealbreaker.","##Increased Complexity and Development Time##","While SPAs can offer smooth, app-like experiences, they come with a higher level of development complexity. To create a truly responsive and efficient SPA, developers often need to use JavaScript frameworks like React, Angular, or Vue.js. These frameworks have steep learning curves, and the architecture required to manage state, handle routing, and ensure smooth client-side navigation can be complex and time-consuming.","On the other hand, MPAs are often more straightforward to develop. They follow a traditional approach where each page is handled as a separate entity. Since each page is independent, developers don’t have to worry as much about client-side routing, state management, or managing complex interactions between different sections of the app. While MPAs still require good web development practices, they typically demand less specialized knowledge compared to SPAs.","Moreover, SPAs require extensive testing and maintenance to ensure that everything works seamlessly across different browsers and devices. Debugging client-side issues can be tricky, and optimizing performance is an ongoing battle, especially as the app scales. MPAs, by contrast, tend to be simpler to debug because each page can be tested independently, and they don’t require the same level of continuous optimization for client-side performance.","##User Experience: The Flip Side##","While SPAs are often lauded for providing a smooth, app-like experience, there are instances where this can actually backfire. Since the content is dynamically loaded, the browser’s back and forward buttons don’t always behave as expected. This can confuse users, especially if they try to navigate to a previous page or share a specific page link. In a traditional MPA, each page has its own unique URL, making navigation intuitive and predictable.","In SPAs, developers must carefully manage the browser history to ensure that users can easily move back and forth through the app. While this is achievable, it requires a level of attention to detail that might be unnecessary in an MPA, where page transitions happen naturally. The lack of clear page reloads in SPAs can also make it harder for users to know where they are within the app, diminishing the overall user experience.","##Security Concerns##","SPAs, because they load content dynamically and handle a significant amount of logic on the client side, often expose more data to the browser than MPAs do. While this might not be a huge problem for every type of application, it increases the risk of exposing sensitive data or providing hackers with more information than they would get from a traditional server-rendered page. Additionally, SPAs are more prone to cross-site scripting (XSS) attacks, as they often rely heavily on JavaScript to render and manage content.","MPAs, in contrast, generally don’t rely as much on client-side logic and often serve more data from the server, which can be more tightly controlled. The server renders the content, meaning less data is exposed to the client, and security measures can be more easily implemented at the server level.","##Conclusion##","While Single Page Applications may seem like the future of web development, especially with their smooth, app-like experiences, they come with a host of challenges that make them less ideal for certain use cases. SPAs can struggle with performance, especially on slower networks; they face significant SEO hurdles; they require more complex development processes; and they can create confusing user experiences with unpredictable navigation. In contrast, Multi-Page Applications offer a simpler, more secure, and SEO-friendly alternative, making them a better choice for many websites, especially those where performance, accessibility, and SEO are critical.","Of course, every project is unique, and the choice between a SPA and an MPA should be driven by the specific needs of the website or app. However, for those who prioritize speed, SEO, and ease of development, MPAs may still have the upper hand."]}],YX={title:"Products Showcase",products:[{title:"Maya UI Framework",subtitle:"NPM Package",size:32,logoSrc:D.ASSETS.LOGOS.MAYA,description:[`A TypeScript only web framework which generates MPA (multi-page
        application) and only needs file server to host the app as opposed
        to other popular web framewroks which creates mostly an SPA and
        needs app server.`]},{title:"Signal",subtitle:"NPM Package",size:40,logoSrc:D.ASSETS.LOGOS.SIGNAL,description:[`Signals are basic data units that can automatically alert functions
        or computations when the data it holds changes. This library is a
        TypeScript implementation of signals.`]},{title:"Batua",subtitle:"Web App",logoSrc:D.ASSETS.LOGOS.BATUA,description:[`A tag based personal money tracker app. The flexibile user-defined
        tags, unlike fixed categories helps in classifying and monitoring expenses
        and earnings more effectively with detailed charts and graphs.`]},{title:"YouTube Attention Score",subtitle:"Chrome Extenstion",logoSrc:D.ASSETS.LOGOS.YT_ATTENTION_SCORE,description:[`A chrome extension for YouTube videos which calculates a score to indicate
        how attention-worthy a video is. It simply derives and shows a ratio of total
        number of likes over total number of views of the video.`]}]},f="YouTube Attention Score",ZQ="01 February 2025",$Q="cyftec@cyfer.tech",FX={NAME:f,ENQUIRY:$Q,POLICY:{EFFECTIVE_DATE:ZQ,PARAS:[`###Privacy Policy for ${f}`,`**Effective Date**: ${ZQ}`,`${f} ("we", "our", "us") is committed to protecting and respecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you install and use our Chrome extension.`,"##1. How the Extension Works",`${f} is designed to work without needing to collect or store any user data. All functionality is processed locally on your device, with no data being sent to our servers or third parties.`,"##2. Information We Do Not Collect","We do not collect, store, or share any personally identifiable information from users of the extension. Specifically:",["**No Personal Data Collection**: We do not collect any personal information, such as your name, email address, or browsing history.","**No Usage Data Collection**: We do not track or log any usage data, including the websites you visit or your interaction with content within the extension.","**No Cookies or Tracking**: Our extension does not use cookies or any form of tracking technologies to monitor your activity."],"##3. Permissions Requested","The extension may request certain permissions to function properly. These permissions are strictly for technical reasons and do not involve collecting or sharing any user data. For example, the extension might request access to the contents of the web pages you visit to enable specific features, but this does not involve storing or sharing any of that data.","##4. Security","While we do not collect any personal information, we are still committed to ensuring the security of the extension. We take steps to ensure the extension is secure and functions as expected, but please remember that no method of data transmission over the internet is 100% secure.","##5. Changes to This Privacy Policy","We may update this Privacy Policy from time to time. If we ever decide to change how we handle data (such as introducing new features that require data collection), we will update this policy and notify you of the changes. Please review this policy periodically for any updates.","##6. Contact Us","If you have any questions or concerns about this Privacy Policy or our extension, feel free to contact us at:",`${$Q}`]}},WX=L(({logoSrc:Q,logoHref:Z,logoSize:J,labelComponent:X})=>{let $=F`${()=>J?.value||32}`;return Y.A({class:"space-mono link black flex items-center justify-start",href:Z,children:[Y.Img({src:Q,height:$,width:$}),Y.If({subject:X,isTruthy:()=>X})]})}),LX=L(({children:Q})=>Y.Div({class:"flex items-center",children:Q})),n=L(({classNames:Q,href:Z,label:J,onClick:X})=>{return Y.Button({class:F`pv2 ph3 pointer bg-transparent hover-bg-gray b--gray ba bw1 br-pill ${Q}`,onclick:X,children:Y.A({class:"no-underline dark-gray hover-white",href:Z,children:J})})}),JQ=L(({className:Q})=>Y.Div({class:F`bl b--moon-gray min-vh-20 ${Q}`})),a=L(({classNames:Q,colorCss:Z,target:J,isSelected:X,href:$,label:W})=>{return Y.A({class:F`link underline ${()=>Z?.value||"red"} ${()=>X?.value?`bg-${Z?.value||"red"}`:""} ${Q}`,target:J,href:$,children:W})}),qX=L(({logoSize:Q,logoSrc:Z,logoHref:J,logoLabelComponent:X,links:$,rightmostComponent:W})=>{return Y.Div({class:"pv3 bg-pale flex items-center justify-between",children:[WX({logoSize:Q,logoSrc:Z,logoHref:J,labelComponent:X}),Y.Div({class:"flex items-center justify-end",children:Y.For({subject:$,itemKey:"label",n:W?1/0:-1,nthChild:W,map:(q)=>{let U=EQ(q).props;return a({isSelected:U.isSelected,classNames:"ml3 pv1 ph2",colorCss:U.colorCss,href:U.href,label:U.label})}})})]})}),zX=L(({classNames:Q,children:Z})=>{return Y.Div({class:F`dn db-ns overflow-y-scroll ${Q}`,style:`
      scrollbar-color: #e8e8e8 #f2f1f0;
      scrollbar-width: thin;
    `,children:Z})}),o=L(({classNames:Q,titleClassNames:Z,itemClassNames:J,header:X,justifyRight:$,links:W,linkColorCss:q,bottomComponent:U})=>Y.Div({class:F`${()=>$?.value?"tr":""} ${Q}`,children:[Y.P({class:F`space-mono mt0 f3 lh-solid ${Z}`,children:X}),Y.Div(Y.For({subject:W,map:(G)=>Y.Div({class:J,children:[a({colorCss:q,href:G.href,label:G.label})]})})),Y.If({subject:U,isTruthy:()=>U})]})),h=L(({classNames:Q,contentClassNames:Z,children:J})=>{return Y.Div({class:F`w-100 ph3 bg-pale ${Q}`,children:[Y.Div({class:F`mw8 center ${Z}`,children:J})]})}),TX=Y.Div({children:[Y.Div({id:"about-us",class:"f2 space-mono lh-copy mt5",children:["# ",Y.Span({class:"highlight",children:"&nbsp;about us&nbsp;"})]}),Y.Div({class:"pa5",children:[Y.Div({class:"flex items-stretch",children:[Y.Img({class:"mr4 flip",src:D.ASSETS.IMAGES.FOUNDER,height:"200",width:"200"}),Y.Div({children:[Y.H3({class:"mt0 mb0",children:"Chandan Kumar, Founder & CTO"}),Y.P({class:"ma1 silver",children:`A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.`})]})]}),n({classNames:"mt4 mb5",label:"Check out careers at Cyfer",onClick:()=>location.assign("/products")})]})]}),kX=Y.Div({children:[Y.Div({id:"blogs",class:"f2 space-mono lh-copy mt5",children:["# ",Y.Span({class:"highlight",children:"&nbsp;blogs&nbsp;"})]}),Y.Div({class:"pa5",children:[Y.Div({class:"flex items-stretch mb5",children:[Y.Img({class:"mr4",src:D.ASSETS.SCREENSHOTS.CODE_EXAMPLE.LIGHT,width:"360"}),Y.Div({children:[Y.H3({class:"mt0 mb0",children:"Dilemma of flux pattern and React"}),Y.P({class:"ma1 silver",children:`A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.`})]})]}),Y.Div({class:"flex items-stretch mb4",children:[Y.Div({children:[Y.H3({class:"mt0 mb0",children:"Dilemma of flux pattern and React"}),Y.P({class:"ma1 silver",children:`A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.
            A chrome extension for YouTube videos which calculates an attention
            score to indicate how attention-worthy a video is. It simply derives and
            shows a ratio of number of likes over number of total views of the video.`})]}),Y.Img({class:"ml4",src:D.ASSETS.SCREENSHOTS.CODE_EXAMPLE.LIGHT,width:"360"})]}),n({classNames:"mb5",href:"/blogs",label:"Check out all blogs"})]})]}),BX=()=>{let Q=document.location.hash;return h({classNames:"sticky top-0",contentClassNames:"z-max bg-pale",children:qX({logoHref:"/",logoSrc:D.ASSETS.LOGOS.CYFER,logoSize:56,logoLabelComponent:Y.A({class:"ml2 link black no-underline",href:"/",children:[Y.Div({class:"f4",children:"CYFER"}),Y.Div({class:"f4",children:"TECH"})]}),links:[{isSelected:Q==="#products",href:"/#products",label:"Products"},{isSelected:Q==="#blogs",href:"/#blogs",label:"Blogs"},{isSelected:Q==="#about-us",href:"/#about-us",label:"About Us"}],rightmostComponent:Y.A({class:"ml4",target:"_blank",href:D.LINKS.CYFER.GITHUB,children:[Y.Img({class:"ba b--none br-100",src:D.LINKS.LOGOS.GITHUB,height:"40",width:"40"})]})})})},UX=h({classNames:"bg-pale-dark",contentClassNames:"flex items-start justify-between pv4",children:[Y.Div({class:"flex flex-column items-stretch justify-between",children:[Y.Div({class:"flex",children:[Y.A({class:"flex no-underline mr3",href:"/",children:[Y.Img({src:D.ASSETS.LOGOS.CYFER,height:"32",width:"32"})]}),Y.Div({children:[Y.P({class:"ma0 f7",children:"© 2025 Cyfer Tech."}),Y.P({class:"mt1 f7",children:"All rights reserved."})]})]}),Y.Span({class:"mt3 mb0",children:[Y.Span({children:"This site is created using "}),a({classNames:"underline",target:"_blank",href:D.LINKS.CYFER.MAYA,label:"Maya"}),Y.Span({children:"."})]})]}),Y.Div({class:"flex items-start justify-between",children:[o({justifyRight:!0,classNames:"pr3",itemClassNames:"mb3",header:"Company",links:[{label:"About us",href:"#about-us"},{label:"Blogs",href:"#blogs"},{label:"Team",href:"#about-us"},{label:"Career",href:"/careers"}]}),JQ({className:"mh4 ph2"}),o({justifyRight:!0,classNames:"pr3",itemClassNames:"mb3",header:"Products",links:[{label:"Maya",href:"/products/maya"},{label:"KarmaJs",href:"/karma"},{label:"Yajman",href:"/yajman"},{label:"Batua",href:"/batua"}]}),JQ({className:"mh4 ph2"}),Y.Div({children:[o({justifyRight:!0,itemClassNames:"mb3",header:"Relations",links:[{label:"Sponsor Us",href:"/sponsor-us"},{label:"FAQs",href:"/faqs"},{label:"Feedback",href:"/feedback"}],bottomComponent:Y.Span({class:"flex items-center justify-end",children:[Y.A({target:"_blank",href:D.LINKS.CYFER.GITHUB,children:[Y.Img({class:"ba b--none br-100",src:D.LINKS.LOGOS.GITHUB,height:"32",width:"32"})]}),Y.A({class:"ml3",target:"_blank",href:D.LINKS.CYFER.X,children:[Y.Img({class:"ba b--none br-100",src:D.LINKS.LOGOS.X,height:"24",width:"24"})]})]})})]})]})]}),GX=L(({title:Q,app:Z})=>{return Y.Html({lang:"en",children:[Y.Head([Y.Title(Q),Y.Link({rel:"stylesheet",href:D.ASSETS.STYLESHEET}),Y.Link({rel:"icon",type:"image/x-icon",href:D.ASSETS.FAVICON})]),Y.Body([Y.Script({src:"main.js",defer:!0}),BX(),h({children:Z}),UX])]})}),HX=Y.Div([Y.Div({id:"products",class:"f2 space-mono lh-copy",children:["# ",Y.Span({class:"highlight",children:"&nbsp;products&nbsp;"})]}),Y.Div({class:"pa5",children:[Y.Div({class:"flex flex-wrap justify-between",children:Y.For({subject:YX.products,map:({title:Q,subtitle:Z,size:J,logoSrc:X,description:$})=>Y.Div({class:"w-45 mb4",children:[Y.Div({class:"flex items-center",children:[Y.Img({src:X,height:`${J??36}`,width:`${J??36}`}),Y.Div({class:"ml3",children:[Y.H3({class:"ma0",children:Q}),Y.Div({class:"gray",children:Z})]})]}),Y.Div({class:"mt3 silver",children:Y.For({subject:$,map:(W)=>Y.P({class:"mt0 mb3",children:W})})})]})})}),n({classNames:"mb4",href:"/products",label:"Check out all products"})]})]),DX=GX({title:"Blogs",app:h({contentClassNames:"pt4 pb5",children:Y.Div({class:"gray grid grid-col-2-5 gap2",children:[zX({classNames:"pa2 sticky top-55",children:Y.For({subject:[...M.map((Q)=>Q.title),...M.map((Q)=>Q.title),...M.map((Q)=>Q.title),...M.map((Q)=>Q.title)],map:(Q,Z)=>Y.Div({class:F`ba br3 pa3 mb3 ${Z===4?"b--transparent b black":"b--near-white moon-gray shadow-hover"}`,children:Q})})}),Y.Div({children:Y.For({subject:M[0].paras,n:0,nthChild:Y.H1({class:"mv0",children:M[0].title}),map:(Q)=>Y.If({subject:Q.startsWith("##"),isTruthy:()=>Y.H3({class:"mt4 mb2",children:Q.replaceAll("##","")}),isFalsy:()=>Y.P({class:"lh-copy",children:Q})})})})]})})}),_X=()=>{H.start("mount"),BQ.resetIdCounter(),DX(),H.start("run")};_X();
